package com.ext.portlet.models.ui;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import com.ext.portlet.NoSuchModelOutputChartOrderException;
import com.ext.portlet.model.ModelOutputChartOrder;
import com.ext.portlet.service.ModelOutputChartOrderLocalServiceUtil;
import com.liferay.counter.service.CounterLocalServiceUtil;
import com.liferay.portal.kernel.exception.SystemException;
import com.liferay.portal.kernel.json.JSONArray;
import com.liferay.portal.kernel.json.JSONFactoryUtil;
import com.liferay.portal.kernel.json.JSONObject;
import com.liferay.portal.kernel.log.Log;
import com.liferay.portal.kernel.log.LogFactoryUtil;

import edu.mit.cci.roma.client.MetaData;
import edu.mit.cci.roma.client.Scenario;
import edu.mit.cci.roma.client.Simulation;
import edu.mit.cci.roma.client.TupleStatus;
import edu.mit.cci.roma.client.Variable;

/**
 * Display holder for a data set that consists of an index ({@link MetaData} with
 * varcontext of {@link mit.simulation.climate.client.MetaData.VarContext#INDEX}) and series data
 * ({@link MetaData} with varcontext of {@link mit.simulation.climate.client.MetaData.VarContext#INDEXED})
 * <p/>
 * Currently, the only backing information for this element is display order.  In the future, additional
 * data may be added
 */
public class ModelOutputIndexedDisplayItem extends ModelOutputDisplayItem {

    private static final Log _log = LogFactoryUtil.getLog(ModelOutputIndexedDisplayItem.class);

    private Simulation sim;
    private Scenario scenario;
    private final String name;
    private MetaData index;
    private final List<ModelOutputSeriesDisplayItem> series = new ArrayList<>();
    private List<ModelOutputSeriesDisplayItem> visibleSeries;
    private final Map<MetaData, Variable> varmap = new HashMap<>();

    private final Map<MetaData, ModelOutputSeriesDisplayItem> seriesMap = new HashMap<>();

    private ModelOutputChartType type = ModelOutputChartType.TIME_SERIES;

    private ModelOutputChartOrder chartModel;

    private final Map<TupleStatus, ModelOutputErrorBehavior> errorBehaviors = new HashMap<TupleStatus, ModelOutputErrorBehavior>();


    /**
     * A model output group is uniquely identified by a name in a simulation.  Currently this may be
     * derived from {@link mit.simulation.climate.client.MetaData#getLabels()} or {@link mit.simulation.climate.client.MetaData#getName()}.
     * Future iterations will make this more consistent.
     * <p/>
     * Note that this constructor implicitly creates a backing store.  Clients should not call this directly,
     * but instead retrieve this element from an {@link ModelDisplay} instance that has been generated by the
     * {@link com.ext.portlet.models.ui.ModelUIFactory}
     */
    ModelOutputIndexedDisplayItem(Simulation s, String name) throws SystemException {
        super(s);
        this.name = name;

        try {
            chartModel = ModelOutputChartOrderLocalServiceUtil.getChartOrder(s, name);
        } catch (NoSuchModelOutputChartOrderException e) {
            createPersistence();
        } catch (SystemException e) {
            _log.error(e);
            throw (e);
        }


    }

    private void createPersistence() throws SystemException {
        Long pk = CounterLocalServiceUtil.increment(ModelOutputChartOrder.class.getName());
        chartModel = ModelOutputChartOrderLocalServiceUtil.createModelOutputChartOrder(pk);
        chartModel.setModelId(getSimulation().getId());
        chartModel.setModelOutputLabel(name);
        chartModel.setModelChartIsVisible(true);
        ModelOutputChartOrderLocalServiceUtil.addModelOutputChartOrder(chartModel);


    }

    @Override
    public String getName() {
        return name;
    }

    @Override
    public ModelOutputChartType getChartType() {
        return type;
    }

    /**
     * Returns the variable for the index if the scenario has been set.
     */
    public Variable getIndexVariable() {
        return varmap.get(getIndex());
    }


    /**
     * Returns the metadata for the index data for this dataset.  Note that
     * unlike series data below, this element is not wrapper in a display class
     * because no additional information is necessary.
     */
    public MetaData getIndex() {
        return index;
    }

    /**
     * If a scenario has been set, returns a list of variables in preferred display order
     */
    public List<Variable> getSeriesVariables() {
        List<Variable> result = new ArrayList<Variable>();
        for (MetaData md : getSeriesMetaData()) {
            result.add(varmap.get(md));
        }

        return result;
    }

    /**
     * Returns a list of metadata in preferred display order.
     */
    public List<MetaData> getSeriesMetaData() {
        List<MetaData> result = new ArrayList<MetaData>();
        for (ModelOutputSeriesDisplayItem item : getSeries()) {
            result.add(item.getMetaData());
        }
        
        return result;
    }

    /**
     * Returns a list of the series metadata wrapped in {@link ModelOutputSeriesDisplayItem},
     * which provides some additional information for interpreting the series.  Series are returned
     * in preferred display order.
     */
    public List<ModelOutputSeriesDisplayItem> getSeries() {
        Collections.sort(series, new Comparator<ModelOutputSeriesDisplayItem>() {
           
            @Override
            public int compare(ModelOutputSeriesDisplayItem o1, ModelOutputSeriesDisplayItem o2) {
                if (o1.getOrder() != -1) {
                    o1.compareTo(o2);
                }
                
                if (o1.getMetaData().getLabels().length >= 2 && o2.getMetaData().getLabels().length >= 2) {
                    return o1.getMetaData().getLabels()[1].compareTo(o2.getMetaData().getLabels()[1]);
                }
                
                return o1.getName().compareTo(o2.getName());
            }
            
        });
        return series;
    }

    public List<ModelOutputSeriesDisplayItem> getVisibleSeries() {
        if (visibleSeries == null) {

            visibleSeries = new ArrayList<ModelOutputSeriesDisplayItem>(getSeries());
            for (Iterator<ModelOutputSeriesDisplayItem> items = visibleSeries.iterator(); items.hasNext();) {
                ModelOutputSeriesDisplayItem item = items.next();
                _log.debug(item.getMetaData().getInternalName()+" is visible");
                if (!item.isVisible()) {
                    _log.debug(item.getMetaData().getInternalName()+" should not be visible");
                    items.remove();
                }
            }
        }
        return visibleSeries;
    }

    public ModelOutputSeriesDisplayItem getSeriesForMetaData(MetaData md) {
        return seriesMap.get(md);
    }


    @Override
    public int getOrder() {

        return null == chartModel ? -1 : (chartModel.getModelOutputChartOrder());
    }

    /**
     * Sets the order of this display item within the parent container.  This is the only
     * publicly accessable setter that is persisted in the backing store.
     */
    @Override
    public void setOrder(int o) throws SystemException {
        if (null != chartModel) {
            chartModel.setModelOutputChartOrder(o);
            ModelOutputChartOrderLocalServiceUtil.updateModelOutputChartOrder(chartModel);
        }
    }


    /**
     * Sets the scenario to enable access to underlying variable through these
     * layout classes.  Does not persist.
     */
    @Override
    public void setScenario(Scenario s) throws IncompatibleScenarioException {
        super.setScenario(s);
        if (sim == null) {
            sim = s.getSimulation();
        }
        if (!s.getSimulation().equals(sim)) {
            throw new IncompatibleScenarioException("Scenario was not generated by simulation " + sim.getName());
        }
        this.scenario = s;
        for (Variable v : scenario.getOutputSet()) {
            varmap.put(v.getMetaData(), v);
        }
        for (ModelOutputSeriesDisplayItem item : getSeries()) {
            item.setScenario(s);
        }

    }


    //following are determined directly from the underlying model, and
    //should not be called from outside of this package


    void setChartType(ModelOutputChartType type) {
        this.type = type;
    }

    void setIndex(MetaData md) {
        this.index = md;
    }

    void addSeriesData(MetaData md) throws SystemException {
        ModelOutputSeriesDisplayItem item = new ModelOutputSeriesDisplayItem(getSimulation(), md);
        visibleSeries = null;
        series.add(item);
        seriesMap.put(md, item);

    }

    @Override
    public ModelOutputDisplayItemType getDisplayItemType() {
        return ModelOutputDisplayItemType.INDEXED;
    }


    public void setErrorBehavior(TupleStatus status, ErrorPolicy policy, String msg) throws SystemException {
        if (status == TupleStatus.OUT_OF_RANGE) {
            chartModel.setModelIndexRangeMessage(msg);
            chartModel.setModelIndexRangePolicy(policy != null ? policy.name() : null);
        } else if (status == TupleStatus.INVALID) {
            chartModel.setModelIndexErrorMessage(msg);
            chartModel.setModelIndexErrorPolicy(policy != null ? policy.name() : null);

        }
        errorBehaviors.remove(status);
        ModelOutputChartOrderLocalServiceUtil.updateModelOutputChartOrder(chartModel);
    }


    @Override
    public ModelOutputErrorBehavior getErrorBehavior(TupleStatus status) {
        ModelOutputErrorBehavior behavior = null;
        if (!errorBehaviors.containsKey(status)) {
            behavior = ModelOutputErrorBehavior.getBehavior(status, chartModel);
            errorBehaviors.put(status, behavior);
        }
        return errorBehaviors.get(status);
    }

    @Override
    public ModelOutputErrorBehavior getRangeError() {
        return getError(getIndexVariable(), TupleStatus.OUT_OF_RANGE, 0);
    }

    @Override
    public ModelOutputErrorBehavior getInvalidError() {
        return getError(getIndexVariable(), TupleStatus.INVALID, 0);
    }

    public void setVisible(boolean b) throws SystemException {
        chartModel.setModelChartIsVisible(b);
        ModelOutputChartOrderLocalServiceUtil.updateModelOutputChartOrder(chartModel);

    }


    public ModelOutputErrorBehavior getOutOfRangeErrorBehavior() {
        return getErrorBehavior(TupleStatus.OUT_OF_RANGE);
    }

    public ModelOutputErrorBehavior getInvalidErrorBehavior() {
        return getErrorBehavior(TupleStatus.INVALID);
    }

    public List<ModelOutputSeriesDisplayItem> getSeriesWithOutOfRangeError() {
        List<ModelOutputSeriesDisplayItem> ret = new ArrayList<ModelOutputSeriesDisplayItem>();
        for (ModelOutputSeriesDisplayItem item : getVisibleSeries()) {
            if (item.getRangeError() != null) {
                ret.add(item);
            }
        }
        return ret;
    }

    public List<ModelOutputSeriesDisplayItem> getSeriesWithInvalidError() {
        List<ModelOutputSeriesDisplayItem> ret = new ArrayList<ModelOutputSeriesDisplayItem>();
        for (ModelOutputSeriesDisplayItem item : getVisibleSeries()) {
            if (item.getInvalidError() != null) {
                ret.add(item);
            }
        }
        return ret;
    }


    @Override
    public boolean isVisible() {
        _log.debug("Checking if "+chartModel.getModelId()+":"+chartModel.getModelOutputLabel()+" is visible");
        if (chartModel.getModelChartIsVisible()) {
            try {
                setVisible(true);
            } catch (SystemException e) {
                _log.error("Error setting chart visibility to default of true", e);
            }
        }
        boolean result = chartModel.getModelChartIsVisible();
        _log.debug(result);
        return  result;
    }
    
    public int getUniqueId() {
        return hashCode();
    }
    
    @Override
    public JSONObject toJson() {
        JSONObject jsonObject = super.toJson();
        JSONArray jsonSeriesArray = JSONFactoryUtil.createJSONArray();
        for (ModelOutputSeriesDisplayItem serie: getSeries()) {
            jsonSeriesArray.put(serie.toJson());
        }
        jsonObject.put("series", jsonSeriesArray);
        if (getIndexVariable() != null) {
            jsonObject.put("index", ModelUIFactory.convertToJson(getIndexVariable()));
        }

        convertErrorBehaviorToJson(jsonObject, "indexedOutOfRangeError", getOutOfRangeErrorBehavior());
        convertErrorBehaviorToJson(jsonObject, "indexedInvalidError", getInvalidErrorBehavior());
        
        return jsonObject;
    }

 
}
