package org.xcolab.client.modeling.models.ui;

import edu.mit.cci.roma.client.MetaData;
import edu.mit.cci.roma.client.Scenario;
import edu.mit.cci.roma.client.Simulation;
import edu.mit.cci.roma.client.TupleStatus;
import edu.mit.cci.roma.client.Variable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.xcolab.client.modeling.ModelingClientUtil;
import org.xcolab.client.modeling.pojo.ModelOutputChartOrder;
import org.xcolab.util.http.exceptions.UncheckedEntityNotFoundException;
import org.xcolab.util.json.JsonUtil;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.json.Json;
import javax.json.JsonArrayBuilder;
import javax.json.JsonObjectBuilder;

/**
 * Display holder for a data set that consists of an index ({@link MetaData} with varcontext of
 * {@link MetaData.VarContext#INDEX}) and series data ({@link
 * MetaData} with varcontext of {@link MetaData.VarContext#INDEXED})
 * <p/>
 * Currently, the only backing information for this element is display order.  In the future,
 * additional data may be added
 */
public class ModelOutputIndexedDisplayItem extends ModelOutputDisplayItem {

    private static final Logger _log = LoggerFactory.getLogger(ModelOutputIndexedDisplayItem.class);
    private final String name;
    private final List<ModelOutputSeriesDisplayItem> series = new ArrayList<>();
    private final Map<MetaData, Variable> varMap = new HashMap<>();
    private final Map<MetaData, ModelOutputSeriesDisplayItem> seriesMap = new HashMap<>();
    private final Map<TupleStatus, ModelOutputErrorBehavior> errorBehaviors = new HashMap<>();
    private Simulation sim;
    private MetaData index;
    private ModelOutputChartType type = ModelOutputChartType.TIME_SERIES;
    private ModelOutputChartOrder chartModel;

    /**
     * A model output group is uniquely identified by a name in a simulation.  Currently this may be
     * derived from {@link MetaData#getLabels()} or {@link
     * MetaData#getName()}. Future iterations will make this more
     * consistent.
     * <p/>
     * Note that this constructor implicitly creates a backing store.  Clients should not call this
     * directly, but instead retrieve this element from an {@link ModelDisplay} instance that has
     * been generated by the {@link ModelUIFactory}
     */
    ModelOutputIndexedDisplayItem(Simulation s, String name) {
        super(s);
        this.name = name;

        try {
            chartModel = ModelingClientUtil.getModelOutputChartOrder(s, name);
        } catch (UncheckedEntityNotFoundException e) {
            createPersistence();
        }
    }

    private void createPersistence() {
        chartModel = new ModelOutputChartOrder();
        chartModel.setModelId(getSimulation().getId());
        chartModel.setModelOutputLabel(name);
        chartModel.setModelChartIsVisible(true);
        chartModel = ModelingClientUtil.createModelOutputChartOrder(chartModel);
    }

    /**
     * Returns a list of the series metadata wrapped in {@link ModelOutputSeriesDisplayItem},
     * which provides some additional information for interpreting the series.  Series are returned
     * in preferred display order.
     */
    public List<ModelOutputSeriesDisplayItem> getSeries() {
        series.sort((o1, o2) -> {
            if (o1.getOrder() != -1) {
                o1.compareTo(o2);
            }

            if (o1.getMetaData().getLabels().length >= 2
                    && o2.getMetaData().getLabels().length >= 2) {
                return o1.getMetaData().getLabels()[1].compareTo(o2.getMetaData().getLabels()[1]);
            }

            return o1.getName().compareTo(o2.getName());
        });
        return series;
    }

    /**
     * Sets the scenario to enable access to underlying variable through these
     * layout classes.  Does not persist.
     */
    @Override
    public void setScenario(Scenario scenario) throws IncompatibleScenarioException {
        super.setScenario(scenario);
        if (sim == null) {
            sim = scenario.getSimulation();
        }
        if (!scenario.getSimulation().equals(sim)) {
            throw new IncompatibleScenarioException(
                    "Scenario was not generated by simulation " + sim.getName());
        }
        for (Variable v : scenario.getOutputSet()) {
            varMap.put(v.getMetaData(), v);
        }
        for (ModelOutputSeriesDisplayItem item : getSeries()) {
            item.setScenario(scenario);
        }

    }

    @Override
    public int getOrder() {

        return null == chartModel ? -1 : (chartModel.getModelOutputChartOrder());
    }

    /**
     * Sets the order of this display item within the parent container.  This is the only
     * publicly accessible setter that is persisted in the backing store.
     */
    @Override
    public void setOrder(int o) {
        if (null != chartModel) {
            chartModel.setModelOutputChartOrder(o);
            ModelingClientUtil.updateModelOutputChartOrder(chartModel);
        }
    }

    @Override
    public String getName() {
        return name;
    }

    void addSeriesData(MetaData md) {
        ModelOutputSeriesDisplayItem
                item = new ModelOutputSeriesDisplayItem(getSimulation(), md);
        series.add(item);
        seriesMap.put(md, item);

    }

    @Override
    public ModelOutputDisplayItemType getDisplayItemType() {
        return ModelOutputDisplayItemType.INDEXED;
    }

    @Override
    public ModelOutputErrorBehavior getErrorBehavior(TupleStatus status) {
        if (!errorBehaviors.containsKey(status)) {
            ModelOutputErrorBehavior behavior =
                    ModelOutputErrorBehavior.getBehavior(status, chartModel);
            errorBehaviors.put(status, behavior);
        }
        return errorBehaviors.get(status);
    }

    @Override
    public ModelOutputErrorBehavior getRangeError() {
        return getError(getIndexVariable(), TupleStatus.OUT_OF_RANGE, 0);
    }


    //following are determined directly from the underlying model, and
    //should not be called from outside of this package

    /**
     * Returns the variable for the index if the scenario has been set.
     */
    public Variable getIndexVariable() {
        return varMap.get(getIndex());
    }

    /**
     * Returns the metadata for the index data for this dataset.  Note that
     * unlike series data below, this element is not wrapper in a display class
     * because no additional information is necessary.
     */
    public MetaData getIndex() {
        return index;
    }

    void setIndex(MetaData md) {
        this.index = md;
    }

    @Override
    public ModelOutputErrorBehavior getInvalidError() {
        return getError(getIndexVariable(), TupleStatus.INVALID, 0);
    }

    @Override
    public boolean isVisible() {
        _log.debug("Checking if {}:{} is visible", chartModel.getModelId(),
                chartModel.getModelOutputLabel());
        if (chartModel.getModelChartIsVisible()) {
            setVisible(true);
        }
        return chartModel.getModelChartIsVisible();
    }

    @Override
    public ModelOutputChartType getChartType() {
        return type;
    }

    void setChartType(ModelOutputChartType type) {
        this.type = type;
    }

    @Override
    public JsonObjectBuilder toJson() {
        final JsonObjectBuilder jsonBuilder = super.toJson();

        JsonArrayBuilder jsonSeriesArray = Json.createArrayBuilder();
        for (ModelOutputSeriesDisplayItem serie : getSeries()) {
            jsonSeriesArray.add(serie.toJson());
        }
        jsonBuilder.add("series", jsonSeriesArray);
        if (getIndexVariable() != null) {
            jsonBuilder.add("index", ModelUIFactory.convertToJson(getIndexVariable()));
        }

        return JsonUtil.nullsafe(jsonBuilder)
                .add("indexedOutOfRangeError",
                        convertErrorBehaviorToJson(getOutOfRangeErrorBehavior()))
                .add("indexedInvalidError", convertErrorBehaviorToJson(getInvalidErrorBehavior()));
    }

    public ModelOutputErrorBehavior getOutOfRangeErrorBehavior() {
        return getErrorBehavior(TupleStatus.OUT_OF_RANGE);
    }

    public ModelOutputErrorBehavior getInvalidErrorBehavior() {
        return getErrorBehavior(TupleStatus.INVALID);
    }

    public void setVisible(boolean b) {
        chartModel.setModelChartIsVisible(b);
        ModelingClientUtil.updateModelOutputChartOrder(chartModel);
    }

    public void setErrorBehavior(TupleStatus status, ErrorPolicy policy, String msg) {
        if (status == TupleStatus.OUT_OF_RANGE) {
            chartModel.setModelIndexRangeMessage(msg);
            chartModel.setModelIndexRangePolicy(policy != null ? policy.name() : null);
        } else if (status == TupleStatus.INVALID) {
            chartModel.setModelIndexErrorMessage(msg);
            chartModel.setModelIndexErrorPolicy(policy != null ? policy.name() : null);

        }
        errorBehaviors.remove(status);
        ModelingClientUtil.updateModelOutputChartOrder(chartModel);
    }

}
